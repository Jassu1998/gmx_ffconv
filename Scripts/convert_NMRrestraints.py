import numpy as np
import csv
import argparse

#The following file is very heavily based on the nmr2gmx script by Anna Sinelnikova, David van der Spoel
# Their code is available at https://github.com/dspoel/nmr2gmxpy/tree/v1.2, https://zenodo.org/records/4022973




# Reads the original restraint itp, ignores first row or comment lines using ;
def read_itp_file(filename):
    # Load all numbers as floats
    return np.loadtxt(filename, comments=['[', ';'])

# Reads mapping file generated by ffmap, the original column is called old, the new one ne
def read_mapping_file(mapping_filename):
    mapping = {}
    with open(mapping_filename, 'r') as file:
        reader = csv.reader(file)
        next(reader)  # skip header
        for line in reader:
            old = int(line[0])
            new = int(line[1])
            mapping[old] = new
    return mapping

# Depending on type of itp, changes atom indices in the first 2 or 4 columns
def apply_mapping(data, mapping, itp_type):
    if itp_type in ['distance', 'orientation']:
        cols_to_map = [0, 1]
    elif itp_type == 'dihedral':
        cols_to_map = [0, 1, 2, 3]
    else:
        raise ValueError(f"Unsupported itp_type: {itp_type}")
    replace_func = np.vectorize(lambda x: mapping.get(int(x), x))
    for col in cols_to_map:
        data[:, col] = replace_func(data[:, col])
    return data

# Headers for different types of itp files
def write_header(fp, itp_type):
    if itp_type == 'distance':
        fp.write("[ distance_restraints ]\n")
        fp.write(";    ai\t    aj\t  type\t index\t type'\t   low\t   up1\t   up2\t   fac\n\n")
    elif itp_type == 'dihedral':
        fp.write("[ dihedral_restraints ]\n")
        fp.write(";    ai\t    aj\t    ak\t    al\t  type\t   phi\t  dphi\t   fac\n\n")
    elif itp_type == 'orientation':
        fp.write("[ orientation_restraints ]\n")
        fp.write(";    ai\t    aj\t  type\t  exp.\t label\t alpha\tconst.\t  obs.\tweight\n")
        fp.write(";      \t      \t      \t      \t      \t   Hz \t nm^3 \t   Hz \t Hz^-2\n\n")
    else:
        raise ValueError(f"Unknown ITP type: {itp_type}")

# --- Save ITP file ---
def save_itp(data, itp_type, filename):
    with open(filename, 'w') as fp:
        write_header(fp, itp_type)
        for row in data:
            if itp_type == 'distance':
                # 9 columns: ai	    aj	  type	 index	 type'	   low	   up1	   up2	   fac
                fp.write("%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\n" %
                         (int(row[0]), int(row[1]), int(row[2]), int(row[3]), int(row[4]),
                          row[5], row[6], row[7], row[8]))
            elif itp_type == 'dihedral':
                # 8 columns  ai	    aj	    ak	    al	  type	   phi	  dphi	   fac
                fp.write("%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\n" %
                         (int(row[0]), int(row[1]), int(row[2]), int(row[3]), int(row[4]),
                          row[5], row[6], row[7]))
            elif itp_type == 'orientation':
                # 9 columns:ai	    aj	  type	  exp.	 label	 alpha	const.	  obs.	weight
                fp.write("%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\t%6s\n" %
                         (int(row[0]), int(row[1]), int(row[2]), int(row[3]), int(row[4]),
                          int(row[5]), row[6], row[7], row[8]))
            else:
                raise ValueError(f"Unknown ITP type: {itp_type}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Map atom indices in ITP files.")
    parser.add_argument("-itp_file", type=str, help="Input ITP file")
    parser.add_argument("-mapping_file", type=str, help="CSV mapping file generated by ffmap")
    parser.add_argument("-type", type=str, choices=['distance', 'orientation', 'dihedral'], required=True,
                        help="ITP type: distance, orientation, or dihedral")
    parser.add_argument("-o", "--output", type=str, default="mapped.itp", help="Output filename")
    args = parser.parse_args()
    data = read_itp_file(args.itp_file)
    mapping = read_mapping_file(args.mapping_file)
    data = apply_mapping(data, mapping, args.type)
    save_itp(data, args.type, args.output)
    print(f"Mapped {args.type} ITP file, new file is saved as {args.output}")
